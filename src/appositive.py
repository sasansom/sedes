import collections
import csv
import os
import unicodedata

Entry = collections.namedtuple("Entry", (
    "word_n", "word", "lemma",
))

def merge_word(entries, work, book_n, line_n):
    return tuple((i,) for i, entry in enumerate(entries))

# Load hardcoded appositive exceptions from an auxiliary CSV file.
ExceptionalAppositive = collections.namedtuple("ExceptionalAppositive",
    ("word", "lemma", "is_prepositive", "is_postpositive")
)
EXCEPTIONAL_APPOSITIVES = {}
with open(os.path.join(os.path.dirname(__file__), "exceptional-appositives.csv")) as f:
    for row in csv.DictReader(f):
        word = unicodedata.normalize("NFD", row["word"])
        lemma = unicodedata.normalize("NFD", row["lemma"])
        coord = (row["work"], row["book_n"], row["line_n"], int(row["word_n"]))
        is_prepositive, is_postpositive = {
            "no":            (False, False),
            "prepositive":   (True,  False),
            "postpositive":  (False, True),
            "bidirectional": (True,  True),
        }[row["appositive"]]
        assert coord not in EXCEPTIONAL_APPOSITIVES, coord
        EXCEPTIONAL_APPOSITIVES[coord] = ExceptionalAppositive(
            word, lemma, is_prepositive, is_postpositive,
        )

ALWAYS_PREPOSITIVE_WORDS = set(unicodedata.normalize("NFD", word) for word in (
    "ἀμ",
    "ἀμφ’",
    "ἀμφί",
    "ἀμφὶ",
    "ἀντί",
    "ἀντὶ",
    "ἀν’",
    "ἀνά",
    "ἀνὰ",
    "ἄνευ",
    "ἀπό",
    "ἀπὸ",
    "ἀπ’",
    "ἀφ’",
    "δί’",
    "διά",
    "διὰ",
    "εἰν",
    "εἰς",
    "ἐκ",
    "ἐν",
    "ἐνί",
    "ἐνὶ",
    "ἐξ",
    "ἐπ’",
    "ἐπί",
    "ἐπὶ",
    "ἐς",
    "ἐφ’",
    "κάγ",
    "κὰγ",
    "κάδ",
    "κὰδ",
    "κάθ’",
    "κάκ",
    "κὰκ",
    "κάπ",
    "κὰπ",
    "κάρ",
    "κὰρ",
    "κάτ",
    "κὰτ",
    "κατ’",
    "κατά",
    "κατὰ",
    "μά",
    "μὰ",
    "μετά",
    "μετὰ",
    "μετ’",
    "μήδ’",
    "μηδέ",
    "μηδὲ",
    "μηθ’",
    "μητ’",
    "μήτε",
    "οὐ",
    "οὐδέ",
    "οὐδὲ",
    "οὐθ’",
    "οὐκ",
    "οὐτ’",
    "οὔτε",
    "οὐχ",
    "παρά",
    "παρὰ",
    "παρ’",
    "περὶ",
    "προς",
    "προτὶ",
    "ὑπὸ",
    "ὑπό",
    "ὑπ’",
    "ὑφ’",
    "αἰ",
    "ἀλλ’",
    "ἀλλά",
    "ἀλλὰ",
    "αὐτάρ",
    "αὐτὰρ",
    "εἰ",
    "ἐπεί",
    "ἐπεὶ",
    "ἐπήν",
    "ἐπὴν",
    "ἠ",
    "ἠδ’",
    "ἠδέ",
    "ἠδὲ",
    "ἠέ",
    "ἠὲ",
    "ἦε",
    "ἠθ’",
    "ἠμέν",
    "ἠμὲν",
    "ἤν",
    "ἠτ’",
    "ἰδ’",
    "ἰδέ",
    "ἰδὲ",
    "ἵν’",
    "ἵνα",
    "καί",
    "καὶ",
    "ὁθ’",
    "ὅθι",
    "ὅπερ",
    "ὁτ’",
    "ὅτε",
    "ὅτι",
    "ὅταν",
    "ὄφρ’",
    "ὄφρα",
    "τόφρ’",
    "τόφρα",
    "τῶ",
    "ὤ",
    "ὢ",
    "ὦ",
    "ὡς",
    "ὥς",
    "ὣς",
    "ὁ",
    "ἡ",
    "τό",
    "τὸ",
    "οἱ",
    "τοί",
    "τοὶ",
    "αἱ",
    "ταί",
    "ταὶ",
    "τά",
    "τὰ",
    "τώ",
    "τὼ",
    "τόν",
    "τὸν",
    "τήν",
    "τὴν",
    "τούς",
    "τοὺς",
    "τώς",
    "τὼς",
    "τάς",
    "τὰς",
    "τοῖο",
    "τοῦ",
    "τῆς",
    "τοῖιν",
    "τῶν",
    "τάων",
    "τῷ",
    "τῇ",
    "τοῖς",
    "τοῖσι",
    "τοῖσιν",
    "τῇς",
    "τῇσι",
    "τῇσιν",
    "ὅς",
    "ὃς",
    "ἥν",
    "ἣν",
    "ὥ",
    "ὣ",
    "ἅ",
    "ἃ",
    "οὕς",
    "οὓς",
    "ἅς",
    "ἃς",
    "οὗ",
    "ἧς",
    "ὧν",
    "ᾧ",
    "ᾗ",
    "οἷς",
    "οἷσι",
    "οἷσιν",
    "ᾗς",
    "ᾗσι",
    "ᾗσιν",
    "εὖ",
    "χὠ",
    "ἕνεκα",
    "ἕνεκ’",
    "ἕνεκεν",
    "εἵνεκα",
))

ALWAYS_POSTPOSITIVE_WORDS = set(unicodedata.normalize("NFD", word) for word in (
    "ἄν",
    "ἂν",
    "ἄρ",
    "ἂρ",
    "ἄρ’",
    "ἄρα",
    "γε",
    "γέ",
    "γ’",
    "γάρ",
    "γὰρ",
    "δέ",
    "δὲ",
    "δ’",
    "δή",
    "δὴ",
    "θην",
    "θήν",
    "θ’",
    "κε",
    "κέ",
    "κεν",
    "κέν",
    "κ’",
    "χ’",
    "μέν",
    "μὲν",
    "νυ",
    "νύ",
    "νυν",
    "νύν",
    "περ",
    "πέρ",
    "ῥ’",
    "ῥα",
    "ῥά",
    "τε",
    "τέ",
    "τ’",
    "πῃ",
    "ποι",
    "ποθ’",
    "ποθε",
    "ποθεν",
    "ποθι",
    "ποτ’",
    "ποτε",
    "που",
    "πω",
    "πως",
    "με",
    "μέ",
    "σε",
    "σέ",
    "σ’",
    "ἑ",
    "ἕ",
    "μιν",
    "μίν",
    "ἥμιν",
    "ἦμιν",
    "ὕμιν",
    "ὗμιν",
    "μευ",
    "σεθεν",
    "σεο",
    "σευ",
    "τευ",
    "ἑθεν",
    "ἑο",
    "εὑ",
    "σφε",
    "σφας",
    "σφεας",
    "σφι",
    "σφιν",
    "σφω",
    "σφωε",
    "σφεων",
    "σφωιν",
    "σφωι",
    "μοι",
    "μοί",
    "μ’",
    "τοι",
    "τοί",
    "σοι",
    "σοί",
    "οἱ",
    "σφισι",
    "σφισιν",
    "σφ’",
    "τις",
    "τι",
    "τινες",
    "τιν’",
    "τινα",
    "τινας",
    "τεο",
    "τινος",
    "του",
    "τινων",
    "τινι",
    "τισι",
    "τισιν",
    "εἰμι",
    "εἰμ’",
    "ἐσσι",
    "ἐσθ’",
    "ἐστ’",
    "ἐστι",
    "ἐστιν",
    "εἰμεν",
    "ἐσμεν",
    "ἐστον",
    "ἐστε",
    "εἰσ’",
    "εἰσι",
    "εἰσιν",
    "ἐών",
    "ἐὼν",
    "φημ’",
    "φημι",
    "φησι",
    "φησιν",
    "φαμεν",
    "φατ’",
    "φατε",
    "φασ’",
    "φασι",
    "φασιν",
    "ἔνι",
    "εἵνεκα",
    "μέτα",
    "πάρα",
    "πάρ’",
    "πέρι",
    "ὕπο",
    "ὕπ’",
    "ὕφ’",
))

# Return a generator that yields ranges of indices of consecutive equal elements
# in s.
def runs(s, key = lambda x: x):
    i = 0
    while i < len(s):
        j = i
        while j < len(s) and key(s[i]) == key(s[j]):
            j += 1
        yield range(i, j)
        i = j

def merge_appositive_group(entries, work, book_n, line_n):
    indices = []
    offset = 0
    prev_is_prepositive = False
    for i, (word_n, word, lemma) in enumerate(entries):
        coord = (work, book_n, line_n, word_n)
        exceptional = EXCEPTIONAL_APPOSITIVES.get(coord)
        if exceptional is not None:
            assert exceptional.word == word, (coord, exceptional, word)
            assert exceptional.lemma == lemma, (coord, exceptional, lemma)
            is_prepositive = exceptional.is_prepositive
            is_postpositive = exceptional.is_postpositive
        else:
            is_prepositive = word in ALWAYS_PREPOSITIVE_WORDS
            is_postpositive = word in ALWAYS_POSTPOSITIVE_WORDS

        if i > 0 and is_postpositive and not prev_is_prepositive:
            offset -= 1
        indices.append(i + offset)
        if is_prepositive:
            offset -= 1

        prev_is_prepositive = is_prepositive
    return tuple(tuple(run) for run in runs(indices))

if __name__ == "__main__":
    for k, v in EXCEPTIONAL_APPOSITIVES.items():
        print(k, v)
