#!/usr/bin/env python3

# Usage:
#   tei2html [OPTION...] IDENTIFIER FILENAME.xml EXPECTANCY.csv > FILENAME.html
#
# IDENTIFIER is a short text identifier for the work that will be copied to the
# output; e.g., "Il.". FILENAME.xml is the name of the XML document containing
# the text of the work. EXPECTANCY is an expectancy CSV file as produced by the
# expectancy program.
#
# The --by option controls the selection of variables according to which
# expectancy is computed. The value passed to --by must match the one that was
# given to the expectancy program earlier. The default value of --by is
# "sedes/lemma". The format is a comma-separated list of distribution variables
# on the left, then a slash character, then a comma-separated list of condition
# variables on the right. Use a backslash to escape commas, slashes, and
# backslashes in variable names. See the expectancy program for examples.

import collections
import csv
import getopt
import html
import math
import sys
import re
import unicodedata

import common
import lemma as lemma_mod
import sedes as sedes_mod
import tei

# Colors for low-to-high color scale.
COLOR_LOW  = (0x00, 0x00, 0x00)
COLOR_HIGH = (0xe6, 0xe6, 0xe6)

# Colors for diverging color scale. The extremes are chosen to be different
# colors of equal lightness, with a lighter gray in the middle.
# Used this tool: https://css.land/lch/.
COLOR_DIVERGING_LOW  = (0xb4, 0x5d, 0x48) # lch(50% 45  40)
COLOR_DIVERGING_MID  = (0xf1, 0xf1, 0xf1) # lch(95%  0   0)
COLOR_DIVERGING_HIGH = (0x20, 0x7d, 0xc2) # lch(50% 45 260)

# Increase this to increase the steepness of the tone mapping operation.
SHADE_MAPPING_ADJUST = 1.5

# Endpoints of the legends that illustrate shade mapping.
SHADE_SCALE_RANGE = (-2.0, 2.0)

# Text on a background of luminance less than this will be displayed as
# light-on-dark rather than dark-on-light.
LUMINANCE_INVERSION_THRESHOLD = 0.3

def usage(file=sys.stdout):
    print(f"""\
Usage: {sys.argv[0]} [OPTION...] IDENTIFIER FILENAME.xml EXPECTANCY.csv > FILENAME.html

WORK.XML is a TEI XML document containing the text of the work.
EXPECTANCY.csv is statistics on a corpus of text as produced by
the expectancy program.

Use the --by option to control the variables according to which
expectancy is computed. This must match the --by value that was provided
to the expectancy program. The default value of --by is "sedes/lemma".
The syntax is a comma-separated list of "distribution variables" on the
left, then a slash, then a comma-separated list of "condition variables"
on the right. Use a backslash to escape commas, slashes, and backslashes
in variable names.

  --by DIST_VARS.../COND_VARS...
              set the grouping variables according to which expectancy
                is computed (default: "sedes/lemma")
  -s NUM, --shade-mapping-adjust=NUM
              change steepness of shade mapping
                (default {SHADE_MAPPING_ADJUST:.1f})
  -h, --help  show this help
""", end="", file=file)

ExpectancyEntry = collections.namedtuple("ExpectancyEntry", ("x", "z"))

# Parse a float string, but return None for the strings "" and "NA".
def float_or_none(s):
    if s in ("", "NA"):
        return None
    else:
        return float(s)

# Parse an expectancy CSV file (as output by the expectancy program). dist_vars
# and cond_vars are the columns to use as a key for looking up x and z values.
# Returns a two-level dict whose top level maps cond_vars to another dict that
# maps dist_vars to ExpectancyEntry.
def parse_expectancy(f, dist_vars, cond_vars):
    stats = {}
    for row in csv.DictReader(f):
        dist_key = tuple(row[k] for k in dist_vars)
        cond_key = tuple(row[k] for k in cond_vars)
        dist_map = stats.setdefault(cond_key, {})
        if dist_key in dist_map:
            raise ValueError(f"duplicate {common.format_dist_cond_vars_spec(dist_vars, cond_vars)} key {(dist_key, cond_key)}")
        dist_map[dist_key] = ExpectancyEntry(
            x = int(row["x"]),
            z = float_or_none(row["z"]),
        )
    return stats

def esc(v):
    return html.escape(v, True)

# Print an HTML start tag with escaped attributes. Entries in the attr list that
# are None are ignored.
def print_start_tag(name, attrs=(), end="\n", **kwargs):
    print(f"<{esc(name)}", end="", **kwargs)
    for attr in attrs:
        if attr is None:
            continue
        k, v = attr
        print(f' {esc(k)}="{esc(normalize(v))}"', end="", **kwargs)
    print(">", end=end, **kwargs)

# Print an HTML end tag.
def print_end_tag(name, end="\n", **kwargs):
    print(f"</{esc(name)}>", end=end, **kwargs)

# Context manager that prints a start tag on enter and an end tag on exit.
class html_element:
    def __init__(self, name, attrs=(), **kwargs):
        self.name = name
        self.attrs = attrs
        self.kwargs = kwargs
    def __enter__(self):
        print_start_tag(self.name, self.attrs, **self.kwargs)
    def __exit__(self, *args):
        print_end_tag(self.name, **self.kwargs)
        return False

# Return an escaped JavaScript string literal.
def js_string(s):
    return '"' + "".join(("\\" + c if c in ("\\", "\"") else c) for c in s) + '"'

# This function needs to be kept in sync with the function of the same name in
# the <script></script> block at the bottom.
def tone_map(z):
    # Logistic function.
    return 1.0 / (1.0 + math.exp(-z * SHADE_MAPPING_ADJUST))

def z_css(z):
    if z is None:
        z = 0.0
    return f"z-{int(100 * tone_map(z))}"

def css_color(sr, sg, sb):
    return f"#{sr:02x}{sg:02x}{sb:02x}"

def srgb_component_to_linear(s):
    # https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation
    u = s / 255.0
    if u <= 0.04045:
        return u / 12.92
    else:
        return math.pow((u + 0.055)/1.055, 12.0/5.0)

def linear_component_to_srgb(u):
    # https://en.wikipedia.org/wiki/SRGB#The_forward_transformation_(CIE_XYZ_to_sRGB)
    if u <= 0.0031308:
        s = 12.92 * u
    else:
        s = 1.055 * math.pow(u, 5.0/12.0) - 0.055
    return int(s * 255 + 0.5)

def srgb_to_linear(sr, sg, sb):
    return tuple(srgb_component_to_linear(c) for c in (sr, sg, sb))

def linear_to_srgb(r, g, b):
    return tuple(linear_component_to_srgb(u) for u in (r, g, b))

def interpolate_srgb(x, s1, s2):
    return linear_to_srgb(*((1.0 - x) * u1 + x * u2 for (u1, u2) in zip(srgb_to_linear(*s1), srgb_to_linear(*s2))))

def diverging_scale(x, low, mid, high):
    if x < 0.5:
        return interpolate_srgb((0.5 - x) / 0.5, mid, low)
    else:
        return interpolate_srgb((x - 0.5) / 0.5, mid, high)

def srgb_luminance(sr, sg, sb):
    # https://en.wikipedia.org/wiki/Relative_luminance#Relative_luminance_in_colorimetric_spaces
    r, g, b = srgb_to_linear(sr, sg, sb)
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;

# Normalize Unicode text for output. While we do all internal processing in NFD,
# NFC is better for HTML output.
# https://www.w3.org/TR/charmod-norm/#normalizationChoice: "Content authors
# SHOULD use Unicode Normalization Form C (NFC) wherever possible for content."
def normalize(s):
    return unicodedata.normalize("NFC", s)

def assign_sedes_for_line(line):
    """From a line, return num_scansions and a sequence of (word, word_n, sedes, shape)
    tuples. sedes will be non-blank if and only if num_scansions is equal to 1."""
    assignments = sedes_mod.analyze(line.text_without_quotes())
    if len(assignments) == 1:
        return len(assignments), tuple((word, word_n, sedes, shape) for (word, word_n, sedes, shape) in assignments[0])
    else:
        # If no scansions or multiple scansions, output "".
        return len(assignments), tuple((word, word_n+1, "", "") for (word_n, word) in enumerate(line.words()))

def process(f, work_identifier, expectancy, dist_vars, cond_vars):
    doc = tei.TEI(f)

    print(f"""\
<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width, initial-scale=1">
<title>{esc(doc.title)}</title>
<style>
""")

    print("""\
@font-face {
    font-family: "Cardo";
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: local("Cardo Regular"), local("Cardo-Regular"), url(fonts/Cardo-Regular.woff) format("woff2");
}
@font-face {
    font-family: "Cardo";
    font-style: italic;
    font-weight: 400;
    font-display: swap;
    src: local("Cardo Italic"), local("Cardo-Italic"), url(fonts/Cardo-Italic.woff) format("woff2");
}

#sidebar {
    background-color: peachpuff;
    position: fixed;
    bottom: 1rem;
    right: 1rem;
    z-index: 1;
    max-width: 100vw;
    max-height: 60vh;
    overflow: auto;
    padding: 0.5rem;
}
#controls {
    display: grid;
    gap: 0.5em;
}
#word-output, #lemma-output {
    font-family: "Cardo";
}
.shape {
    /* Prevent longa from running together: https://github.com/sasansom/sedes/issues/58 */
    letter-spacing: 0.5ex;
}
#infobox {
    line-height: 1rem;
}
#infobox th {
    padding-right: 0.5em;
}
#infobox th, #infobox td {
    text-align: left;
}
#sedes-dist {
    background-color: white;
    border-spacing: 1px;
}
#sedes-dist th {
    font-weight: inherit;
}
#sedes-dist th[scope=col] {
    text-align: center;
    min-width: 6.5ex;
    background-color: powderblue;
}
#sedes-dist th[scope=col].selected {
    background-color: coral;
}
#sedes-dist th[scope=col], #sedes-dist td {
    font-size: x-small;
}
#sedes-dist th[scope=row] {
    text-align: left;
}
#sedes-dist td {
    text-align: right;
}
#sedes-dist caption {
    text-align: left;
}

h1 a, h2 a {
    color: inherit;
    text-decoration: inherit;
}

.error {
    background-color: firebrick;
}
.show-undefined-expectancy .undefined-expectancy {
    background-color: gold;
}

summary, .word {
    cursor: pointer;
}
.word:target {
    background-color: powderblue;
}

.line, .grid-markers {
    font-family: "Cardo";
    font-size: 120%;
    line-height: 140%;
    white-space: nowrap;
}

.line::before {
    content: attr(data-lineno);
    display: inline-block;
    position: absolute;
    left: -3rem;
    width: 2rem;
    text-align: right;
    color: gray;
    font-size: 80%;
}

.text, .grid-markers {
    margin-left: 3rem;
    position: relative;
}
/* Keep background colors and full saturation when printing. */
.text, #vis-helper, #sedes-dist {
    color-adjust: exact;
    -webkit-print-color-adjust: exact;
}

.grid-markers {
    color: gray;
    opacity: 0;
    overflow: hidden;
    visibility: hidden;
    transition-property: opacity, visibility;
    transition-duration: 0.5s;
    height: 2rem;
}
.grid-markers.visible {
    opacity: 1;
    visibility: visible;
}
.grid {
    position: relative;
}
.grid .line {
    visibility: hidden;
}
.grid .line::before, .grid .line .word {
    visibility: visible;
}
.grid .s1,
.grid .s2,
.grid .s2_5,
.grid .s3,
.grid .s4,
.grid .s4_5,
.grid .s5,
.grid .s6,
.grid .s6_5,
.grid .s7,
.grid .s8,
.grid .s8_5,
.grid .s9,
.grid .s10,
.grid .s10_5,
.grid .s11,
.grid .s12
{
    position: absolute;
}
.grid .s1 { left: 0; }
.grid .s2 { left: 5ex; }
.grid .s2_5 { left: 10ex; }
.grid .s3 { left: 16ex; }
.grid .s4 { left: 21ex; }
.grid .s4_5 { left: 26ex; }
.grid .s5 { left: 31ex; }
.grid .s6 { left: 34ex; }
.grid .s6_5 { left: 40ex; }
.grid .s7 { left: 45ex; }
.grid .s8 { left: 50ex; }
.grid .s8_5 { left: 54ex; }
.grid .s9 { left: 59ex; }
.grid .s10 { left: 64ex; }
.grid .s10_5 { left: 68ex; }
.grid .s11 { left: 74ex; }
.grid .s12 { left: 78ex; }
""")

    print("""\
.shade-bubbles .word,
.shade-bubbles-diverging .word {
    --r: 2.5rem; /* radius of 100% circle */
    position: relative;
}
.shade-bubbles .word::before,
.shade-bubbles-diverging .word::before {
    background-color: magenta; /* highlight any missing background-colors */
}
.shade-bubbles .word::before,
.shade-bubbles-diverging .word::before {
    --s: 1.5em;
    position: absolute;
    opacity: 0.5;
    border-radius: 50%;
    z-index: -1;
    content: "";
    width: var(--s);
    height: var(--s);
    bottom: calc(var(--s) / -2 + 0.667em);
    left: calc(var(--s) / -2 + 1ch);
}

.size-bubbles .word {
    --r: 2em; /* radius of 100% circle */
    position: relative;
}
.size-bubbles .word::before {
    background-color: magenta; /* highlight any missing background-colors */
}
.size-bubbles .word::before {
    position: absolute;
    background-color: orange;
    opacity: 0.5;
    border-radius: 50%;
    z-index: -1;
    content: "";
    width: var(--s);
    height: var(--s);
    bottom: calc(var(--s) / -2 + 0.667em);
    left: calc(var(--s) / -2 + 1ch);
}
""")

    def interval_range(start, stop, num_steps):
        return [start + (stop - start) * (float(i) / num_steps) for i in range(num_steps + 1)]

    print("""\
#shade-scale, #shade-diverging-scale {
    display: none;
    justify-content: space-between;
    padding: 0.25em;
}
""")
    print("""\
#shade-scale {{
    background: linear-gradient(to right, {});
    color: gray;
}}
#vis-helper.shade-text #shade-scale,
#vis-helper.shade-bubbles #shade-scale {{
    display: flex;
}}
""".format(", ".join(css_color(*(interpolate_srgb(tone_map(z), COLOR_LOW, COLOR_HIGH))) for z in interval_range(*SHADE_SCALE_RANGE, 50))))

    print("""\
#shade-diverging-scale {{
    background: linear-gradient(to right, {});
    color: black;
}}
#vis-helper.shade-text-diverging #shade-diverging-scale,
#vis-helper.shade-bubbles-diverging #shade-diverging-scale {{
    display: flex;
}}
""".format(", ".join(css_color(*(diverging_scale(tone_map(z), COLOR_DIVERGING_LOW, COLOR_DIVERGING_MID, COLOR_DIVERGING_HIGH))) for z in interval_range(*SHADE_SCALE_RANGE, 50))))

    for n in range(101):
        r = n / 100.0

        shade_color = interpolate_srgb(r, COLOR_LOW, COLOR_HIGH)
        diverging_color = diverging_scale(r, COLOR_DIVERGING_LOW, COLOR_DIVERGING_MID, COLOR_DIVERGING_HIGH)

        print(f".shade-text .sedes .z-{n} {{ color: {css_color(*shade_color)}; }}")
        print(f"#sedes-dist.shade-text .z-{n} {{ color: {'white' if srgb_luminance(*shade_color) < LUMINANCE_INVERSION_THRESHOLD else 'black'}; background-color: {css_color(*shade_color)}; }}")
        print(f".shade-text-diverging .sedes .z-{n} {{ color: {css_color(*diverging_color)}; }}")
        print(f"#sedes-dist.shade-text-diverging .z-{n} {{ color: {'white' if srgb_luminance(*diverging_color) < LUMINANCE_INVERSION_THRESHOLD else 'black'}; background-color: {css_color(*diverging_color)}; }}")
        print(f".shade-bubbles .sedes .z-{n}::before {{ background-color: {css_color(*shade_color)}; }}")
        print(f"#sedes-dist.shade-bubbles .z-{n} {{ color: {'white' if srgb_luminance(*shade_color) < LUMINANCE_INVERSION_THRESHOLD else 'black'}; background-color: {css_color(*shade_color)}; }}")
        print(f".shade-bubbles-diverging .sedes .z-{n}::before {{ background-color: {css_color(*diverging_color)}; }}")
        print(f"#sedes-dist.shade-bubbles-diverging .z-{n} {{ color: {'white' if srgb_luminance(*diverging_color) < LUMINANCE_INVERSION_THRESHOLD else 'black'}; background-color: {css_color(*diverging_color)}; }}")
        area = math.sqrt(1.0 - r)
        print(f".size-bubbles .sedes .z-{n}::before {{ --s: calc(var(--r) * {area:.3f}); }}")

    print("</style>")
    print("</head>")

    print("<body>")

    # Format a floating-point number as appropriate for HTML, with a real minus
    # sign.
    def fmt_float(x):
        return esc(f"{x:+.3g}".replace("-", "−"))
    print("""\
<details id=sidebar open>
<summary>Controls</summary>

<div>
<form id=controls>
<label><input name=grid type=checkbox> Align to <i>sedes</i> grid</label>
<div>
<select name=style>
<option value=>No highlighting</option>
<option value=shade-text>Shade text</option>
<option value=shade-text-diverging>Shade text, diverging</option>
<option value=shade-bubbles>Shade bubbles</option>
<option value=shade-bubbles-diverging>Shade bubbles, diverging</option>
<option value=size-bubbles>Size bubbles</option>
</select>
<div id=vis-helper>
<div id=shade-scale>
<span>{min}</span><span>{max}</span>
</div>
<div id=shade-diverging-scale>
<span>{min}</span><span>{max}</span>
</div>
</div>
</div>
<label><input name=show-undefined-expectancy type=checkbox> Highlight undefined <var>z</var>-scores</label>
</form>

<hr>

<span><output id=loc-output></output> <a id=link-output></a></span>

<table id=infobox>
<tr><th scope=row>word</th><td><output id=word-output></output></td></tr>
<tr><th scope=row>shape</th><td class=shape><output id=shape-output></output></td></tr>
<tr><th scope=row><i>sedes</i></th><td><output id=sedes-output></output></td></tr>
<tr><th scope=row>lemma</th><td><output id=lemma-output></output></td></tr>
<tr><th scope=row>Σ<var>x</var></th><td><output id=sumx-output></output></td></tr>
</table>

<table id=sedes-dist>
<caption>Expectancy according to {expectancy_vars}</caption>
<tr>
  <td></td>
  <th scope=col id=sedes-dist-header-1>1</th>
  <th scope=col id=sedes-dist-header-2>2</th>
  <th scope=col id=sedes-dist-header-2.5>2.5</th>
  <th scope=col id=sedes-dist-header-3>3</th>
  <th scope=col id=sedes-dist-header-4>4</th>
  <th scope=col id=sedes-dist-header-4.5>4.5</th>
  <th scope=col id=sedes-dist-header-5>5</th>
  <th scope=col id=sedes-dist-header-6>6</th>
  <th scope=col id=sedes-dist-header-6.5>6.5</th>
  <th scope=col id=sedes-dist-header-7>7</th>
  <th scope=col id=sedes-dist-header-8>8</th>
  <th scope=col id=sedes-dist-header-8.5>8.5</th>
  <th scope=col id=sedes-dist-header-9>9</th>
  <th scope=col id=sedes-dist-header-10>10</th>
  <th scope=col id=sedes-dist-header-10.5>10.5</th>
  <th scope=col id=sedes-dist-header-11>11</th>
  <th scope=col id=sedes-dist-header-12>12</th>
</tr>
<tr>
  <th scope=row><var>x</var></th>
  <td><output id=output-x-1></output></td>
  <td><output id=output-x-2></output></td>
  <td><output id=output-x-2.5></output></td>
  <td><output id=output-x-3></output></td>
  <td><output id=output-x-4></output></td>
  <td><output id=output-x-4.5></output></td>
  <td><output id=output-x-5></output></td>
  <td><output id=output-x-6></output></td>
  <td><output id=output-x-6.5></output></td>
  <td><output id=output-x-7></output></td>
  <td><output id=output-x-8></output></td>
  <td><output id=output-x-8.5></output></td>
  <td><output id=output-x-9></output></td>
  <td><output id=output-x-10></output></td>
  <td><output id=output-x-10.5></output></td>
  <td><output id=output-x-11></output></td>
  <td><output id=output-x-12></output></td>
</tr>
<tr>
  <th scope=row><var>x</var>/Σ<var>x</var></th>
  <td><output id=output-fracx-1></output></td>
  <td><output id=output-fracx-2></output></td>
  <td><output id=output-fracx-2.5></output></td>
  <td><output id=output-fracx-3></output></td>
  <td><output id=output-fracx-4></output></td>
  <td><output id=output-fracx-4.5></output></td>
  <td><output id=output-fracx-5></output></td>
  <td><output id=output-fracx-6></output></td>
  <td><output id=output-fracx-6.5></output></td>
  <td><output id=output-fracx-7></output></td>
  <td><output id=output-fracx-8></output></td>
  <td><output id=output-fracx-8.5></output></td>
  <td><output id=output-fracx-9></output></td>
  <td><output id=output-fracx-10></output></td>
  <td><output id=output-fracx-10.5></output></td>
  <td><output id=output-fracx-11></output></td>
  <td><output id=output-fracx-12></output></td>
</tr>
<tr>
  <th scope=row><var>z</var></th>
  <td><output id=output-z-1></output></td>
  <td><output id=output-z-2></output></td>
  <td><output id=output-z-2.5></output></td>
  <td><output id=output-z-3></output></td>
  <td><output id=output-z-4></output></td>
  <td><output id=output-z-4.5></output></td>
  <td><output id=output-z-5></output></td>
  <td><output id=output-z-6></output></td>
  <td><output id=output-z-6.5></output></td>
  <td><output id=output-z-7></output></td>
  <td><output id=output-z-8></output></td>
  <td><output id=output-z-8.5></output></td>
  <td><output id=output-z-9></output></td>
  <td><output id=output-z-10></output></td>
  <td><output id=output-z-10.5></output></td>
  <td><output id=output-z-11></output></td>
  <td><output id=output-z-12></output></td>
</tr>
</table>

</div>
</details>""".format(
    min = fmt_float(SHADE_SCALE_RANGE[0]),
    max = fmt_float(SHADE_SCALE_RANGE[1]),
    expectancy_vars = ", ".join(f"<var>{esc(var)}</var>" for var in dist_vars) +
                      " / " +
                      ", ".join(f"<var>{esc(var)}</var>" for var in cond_vars),
))

    print_start_tag("article")

    with html_element("header"):
        with html_element("h1", end=""):
            print(esc(normalize(doc.title)), end="")
        print()

    # Values of cond_vars whose expectancy entries we actually need for this
    # text, built up as we go.
    expectancy_needed = set()

    # Sum of x per unique values of cond_vars.
    sum_x = {}
    for cond_key, dist_map in expectancy.items():
        sum_x[cond_key] = sum(expectancy_entry.x for expectancy_entry in dist_map.values())

    # Cache of already emitted automatically generated HTML element ids, to
    # avoid duplicated.
    seen_ids = set()

    book_n = None
    for loc, line in doc.lines():
        if loc.book_n != book_n:
            if book_n is not None:
                print_end_tag("div")
                print_end_tag("section")
            print()

            book_id = f"book-{loc.book_n}"
            if book_id in seen_ids:
                book_id = None
            else:
                seen_ids.add(book_id)

            # Begin book.
            print_start_tag("section", (
                ("id", book_id) if book_id else None,
                ("data-bookno", loc.book_n),
            ))

            with html_element("h2", end=""):
                with html_element("a", (("href", f"#book-{loc.book_n}"),), end=""):
                    print(esc(loc.book_n), end="")
            print()

            print("""\
<div class="grid-markers grid">
<span class="s1">1</span>
<span class="s2">2</span>
<span class="s2_5">2.5</span>
<span class="s3">3</span>
<span class="s4">4</span>
<span class="s4_5">4.5</span>
<span class="s5">5</span>
<span class="s6">6</span>
<span class="s6_5">6.5</span>
<span class="s7">7</span>
<span class="s8">8</span>
<span class="s8_5">8.5</span>
<span class="s9">9</span>
<span class="s10">10</span>
<span class="s10_5">10.5</span>
<span class="s11">11</span>
<span class="s12">12</span>
</div>""")
            print("<div class=text>")
        book_n = loc.book_n

        line_id = f"book-{loc.book_n}-line-{loc.line_n}"
        if line_id in seen_ids:
            line_id = None
        else:
            seen_ids.add(line_id)

        # Begin line.
        print_start_tag("span", (
            ("id", line_id) if line_id else None,
            ("class", "line"),
            ("data-lineno", f"{loc.line_n}"),
        ), end="")

        buffered_nonwords = []
        prev_sedes = None
        # We will walk word_entries and line.tokens in parallel, popping an
        # entry from word_entries every time a token has type WORD.
        _, word_entries = assign_sedes_for_line(line)
        word_entries = list(word_entries)
        for token in line.tokens:
            if token.type != tei.Token.Type.WORD:
                if prev_sedes is None:
                    print(esc(normalize(token.text)), end="")
                else:
                    # These nonwords may or may not belong to the currently open
                    # sedes span--it depends on whether the sedes of the next
                    # word is the same or not.
                    buffered_nonwords.append(token)
                continue

            while True:
                try:
                    word, word_n, sedes, shape = word_entries.pop(0)
                except IndexError:
                    sedes = None
                    shape = None
                    break
                if word:
                    if word.lower() != token.text.lower():
                        print(f"warning: book {loc.book_n} line {loc.line_n} word {word_n} {token.text!r} does not match scansion word {word!r}", file=sys.stderr)
                    break
                # Ignore empty metrical placeholder words (as found in known.py).

            # Is the sedes for this word the the same as the sedes of the
            # previous word (if any)?
            if sedes is not None and sedes == prev_sedes:
                # Include these nonwords in the currently open sedes span.
                print(esc("".join(token.text for token in buffered_nonwords)), end="")
                buffered_nonwords.clear()
            else:
                if prev_sedes is not None:
                    # Close the currently open sedes span.
                    print_end_tag("span", end="")
                # The nonwords in between belong to neither sedes span.
                print(esc(normalize(re.sub(r"\s+", "\n", "".join(token.text for token in buffered_nonwords)))), end="")
                buffered_nonwords.clear()
                if sedes is not None:
                    # Begin new sedes.
                    print_start_tag("span", (
                        ("class", f"sedes s{sedes.replace('.', '_')}"),
                    ), end="")
            prev_sedes = sedes

            word_attrs = collections.OrderedDict()
            if line_id is not None:
                # We omit the per-word id for *all* words in a line that itself
                # does not have an id; i.e., we check whether line_id is set,
                # not whether the word id is in seen_ids. A None line_id means
                # we have already emitted a line with that number, and we do not
                # want to have ids on just the last few words of this line, when
                # this line has more words than the already emitted one.
                word_attrs["id"] = f"book-{loc.book_n}-line-{loc.line_n}-word-{word_n}"

            word_attrs["class"] = "word"

            title_attr = []
            lemma = lemma_mod.lookup(word, (work_identifier, loc.book_n, loc.line_n, word_n))
            if lemma is None:
                lemma = word # Use the word itself as lemma if lemmatization fails.
            word_attrs["data-wordno"] = str(word_n)
            if lemma is not None:
                word_attrs["data-lemma"] = normalize(lemma);
                title_attr.append(f"lemma={normalize(lemma)}")
            if sedes is not None:
                word_attrs["data-sedes"] = sedes;
                title_attr.append(f"sedes={sedes}")

            # These are the variables whose values we know how to produce and
            # are usable in dist_vars and cond_vars lookups.
            VAR_VALUES = {
                "work": work_identifier,
                "book_n": loc.book_n,
                "line_n": loc.line_n,
                "word_n": word_n,
                "word": word,
                "lemma": lemma,
                "sedes": sedes,
                "metrical_shape": shape,
            }
            dist_key = tuple(VAR_VALUES[var] for var in dist_vars)
            cond_key = tuple(VAR_VALUES[var] for var in cond_vars)
            expectancy_needed.add(cond_key)
            expectancy_entry = expectancy.get(cond_key, {}).get(dist_key)
            if expectancy_entry is not None:
                title_attr.append(f"x={expectancy_entry.x}")
                title_attr.append(f"Σx={sum_x[cond_key]}")
                word_attrs["class"] += " " + esc(z_css(expectancy_entry.z))
                if expectancy_entry.z is not None:
                    z_fmt = f"{expectancy_entry.z:+.8}"
                    title_attr.append(f"z={z_fmt.replace('-', '−')}")
                else:
                    word_attrs["class"] += " undefined-expectancy"
            else:
                print(f"warning: no expectancy score for book {loc.book_n} line {loc.line_n} word {word_n}: {common.format_dist_cond_vars_spec(dist_vars, cond_vars)} {(dist_key, cond_key)}", file=sys.stderr)
                word_attrs["class"] += " error"
            if shape is not None:
                word_attrs["data-shape"] = normalize(shape)
                title_attr.append(f"shape={normalize(shape)}")
            if title_attr:
                word_attrs["title"] = " ".join(title_attr)

            # Span for a single word.
            with html_element("span", word_attrs.items(), end=""):
                print(esc(normalize(token.text)), end="")

        if word_entries:
            print(f"warning: book {loc.book_n} line {loc.line_n} word {word_n} leftover scansion words {word_entries}", file=sys.stderr)

        if prev_sedes is not None:
            # Close the last remaining open sedes span.
            print_end_tag("span", end="")
        print(esc(normalize("".join(token.text for token in buffered_nonwords))), end="")
        buffered_nonwords.clear()

        # End line.
        print_end_tag("span")
        print_start_tag("br")

    if book_n is not None:
        print_end_tag("div")
        print_end_tag("section")

    print_end_tag("article")

    print("<script defer>")
    print("\"use strict\";")

    print("const WORK = " + js_string(work_identifier) + ";")
    print("const DIST_VARS = [" + ", ".join(js_string(var) for var in dist_vars) + "];")
    print("const COND_VARS = [" + ", ".join(js_string(var) for var in cond_vars) + "];")

    escape_re = re.compile(r"[,\\]")
    def escape(values):
        return ",".join(normalize(escape_re.sub(lambda m: f"\\{m.group()}", x)) for x in values)

    print("const EXPECTANCY = new Map([");
    for cond_key in sorted(expectancy.keys()):
        if cond_key not in expectancy_needed:
            continue
        dist_map = expectancy[cond_key]
        print(f"[{js_string(escape(cond_key))}, new Map([")
        for dist_key in sorted(dist_map.keys()):
            expectancy_entry = dist_map[dist_key]
            fields = [("x", str(expectancy_entry.x)),]
            if expectancy_entry.z is not None:
                fields.append(("z", f"{expectancy_entry.z:+.8}"))
            value = ", ".join(f"{name}: {value}" for name, value in fields)
            print(f"  [{js_string(escape(dist_key))}, {{{value}}}],")
        print("])],")
    print("]);");

    print(f"const SHADE_MAPPING_ADJUST = {SHADE_MAPPING_ADJUST};")

    print("""
const LOC_OUTPUT = document.getElementById("loc-output");
const LINK_OUTPUT = document.getElementById("link-output");
const WORD_OUTPUT = document.getElementById("word-output");
const SHAPE_OUTPUT = document.getElementById("shape-output");
const SEDES_OUTPUT = document.getElementById("sedes-output");
const LEMMA_OUTPUT = document.getElementById("lemma-output");
const SUMX_OUTPUT = document.getElementById("sumx-output");
const SEDES_DIST = document.getElementById("sedes-dist");

function format_signed_float(x, digits) {
    return (x >= 0 ? "+" : "−") + Math.abs(x).toFixed(digits);
}

// This function needs to be kept in sync with the Python function of the same
// name.
function tone_map(z) {
    return 1.0 / (1.0 + Math.exp(-z * SHADE_MAPPING_ADJUST))
}

// Backslash-escape commas every element in values, then join the escaped
// strings with a comma as separator. This function provides a way of using
// arrays of strings as Map keys.
function escape(values) {
    return values.map(x => x.replace(/[,\\\\]/, m => "\\\\"+m)).join(",");
}

function info(target) {
    // Search upward for the containing book and line.
    let bookno, lineno, wordno;
    for (let elem = target;
         (bookno == null || lineno == null || wordno == null) && elem != null;
         elem = elem.parentElement)
    {
        bookno = bookno ?? elem.getAttribute("data-bookno");
        lineno = lineno ?? elem.getAttribute("data-lineno");
        wordno = wordno ?? elem.getAttribute("data-wordno");
    }
    LOC_OUTPUT.textContent = [
        (bookno != null) && `book ${bookno}`,
        (lineno != null) && `line ${lineno}`,
        (wordno != null) && `word ${wordno}`,
    ].filter(x => x).join(", ");
    LINK_OUTPUT.href = "#" + target.id;
    LINK_OUTPUT.textContent = "link";

    // These are the variables whose values we know how to produce and are
    // usable in DIST_VARS and COND_VARS lookups.
    const VAR_VALUES = new Map([
        ["work", WORK],
        ["book_n", bookno],
        ["line_n", lineno],
        ["word_n", wordno],
        // Lowercase the literal word from the text, to match what
        // hexameter.analyze_line_metrical does internally and what is stored in
        // tei2csv output.
        // https://github.com/sasansom/sedes/blob/526941f65bf88efb82db7d3bfbfe632e4f0d40ff/src/hexameter/scan.py#L378
        ["word", target.textContent.toLowerCase()],
        ["lemma", target.getAttribute("data-lemma")],
        ["sedes", target.getAttribute("data-sedes")],
        ["metrical_shape", target.getAttribute("data-shape")],
    ]);

    const dist_key = DIST_VARS.map(x => VAR_VALUES.get(x));
    const cond_key = COND_VARS.map(x => VAR_VALUES.get(x));
    let sum_x = 0;
    for (const entry of EXPECTANCY.get(escape(cond_key))?.values())
        sum_x += entry.x;

    WORD_OUTPUT.textContent = VAR_VALUES.get("word");
    SHAPE_OUTPUT.textContent = VAR_VALUES.get("metrical_shape") ?? "";
    SEDES_OUTPUT.textContent = VAR_VALUES.get("sedes") ?? "";
    LEMMA_OUTPUT.textContent = VAR_VALUES.get("lemma") ?? "";
    SUMX_OUTPUT.textContent = sum_x ?? "";

    for (let elem of SEDES_DIST.getElementsByTagName("th"))
        elem.classList.toggle("selected", false);
    let sedes = VAR_VALUES.get("sedes");
    if (sedes != null)
        document.getElementById(`sedes-dist-header-${sedes}`).classList.toggle("selected", true);

    // Fill out the sedes distribution table. This is a special case: the table
    // does not generalize to show distributions over other variables. When
    // dist_key and cond_key do not mention sedes, all the columns in the table
    // will be the same.
    const POSSIBLE_SEDES = [1, 2, 2.5, 3, 4, 4.5, 5, 6, 6.5, 7, 8, 8.5, 9, 10, 10.5, 11, 12].map(sedes => sedes.toString());
    for (const sedes of POSSIBLE_SEDES) {
        // Compute dist_key and cond_key as above, but override sedes with each
        // element of POSSIBLE_SEDES in turn.
        const dist_key = DIST_VARS.map(x => x == "sedes" ? sedes : VAR_VALUES.get(x));
        const cond_key = COND_VARS.map(x => x == "sedes" ? sedes : VAR_VALUES.get(x));
        let {x, z} = EXPECTANCY.get(escape(cond_key))?.get(escape(dist_key)) ?? {};
        // Recompute sum_x for each column.
        let sum_x = 0;
        for (const entry of EXPECTANCY.get(escape(cond_key))?.values())
            sum_x += entry.x;

        let output_x = document.getElementById(`output-x-${sedes}`);
        let output_fracx = document.getElementById(`output-fracx-${sedes}`);
        let output_z = document.getElementById(`output-z-${sedes}`);
        if (x !== undefined) {
            output_x.textContent = x;
            output_fracx.textContent = (x / sum_x * 100).toFixed(1) + "%";
        } else {
            output_x.textContent = "";
            output_fracx.textContent = "";
        }
        output_z.parentNode.className = output_z.parentNode.className.split(" ").filter(name => !/^z-\d+$/.test(name)).join(" ");
        if (z !== undefined) {
            output_z.textContent = format_signed_float(z, 2);
            output_z.parentNode.classList.add(`z-${(tone_map(z) * 100).toFixed()}`);
        } else {
            output_z.textContent = "";
        }
        output_z.parentNode.classList.toggle("undefined-expectancy", x !== undefined && z === undefined);
    }
}
for (let word of document.querySelectorAll("article .word"))
    word.addEventListener("click", event => info(event.target));
// If there's a word selected in the URL hash, fill out the infobox.
if (window.location.hash != "") {
    let elem = document.getElementById(window.location.hash.slice(1));
    if (elem?.classList?.contains("word"))
        info(elem);
}

const ALL_STYLES = [
    "shade-text",
    "shade-text-diverging",
    "shade-bubbles",
    "shade-bubbles-diverging",
    "size-bubbles",
];
const CONTROLS = document.getElementById("controls");
CONTROLS["grid"].addEventListener("change", event => {
    for (let elem of document.querySelectorAll(".grid-markers")) {
        elem.classList.toggle("visible", event.target.checked);
    }
    for (let elem of document.querySelectorAll(".text")) {
        elem.classList.toggle("grid", event.target.checked);
    }
});
CONTROLS["grid"].dispatchEvent(new Event("change"));
const VIS_HELPER = document.getElementById("vis-helper");
CONTROLS["style"].addEventListener("change", event => {
    for (let elem of document.querySelectorAll(".text, #sedes-dist")) {
        elem.classList.remove(...ALL_STYLES);
        if (event.target.value)
            elem.classList.add(event.target.value);
    }
    VIS_HELPER.classList.remove(...ALL_STYLES);
    if (event.target.value)
        VIS_HELPER.classList.add(event.target.value);
});
CONTROLS["style"].dispatchEvent(new Event("change"));
CONTROLS["show-undefined-expectancy"].addEventListener("change", event => {
    for (let elem of document.querySelectorAll(".text, #sedes-dist")) {
        elem.classList.toggle("show-undefined-expectancy", event.target.checked);
    }
});
CONTROLS["show-undefined-expectancy"].dispatchEvent(new Event("change"));
</script>
""")
    print("</body>")
    print("</html>")

def main():
    # Default grouping variables if not specified with --by.
    dist_cond_vars_spec = common.DEFAULT_DIST_COND_VARS_SPEC

    opts, args = getopt.gnu_getopt(sys.argv[1:], "hs:", (
        "by=",
        "help",
        "shade-mapping-adjust=",
    ))
    for o, a in opts:
        if o == "--by":
            dist_cond_vars_spec = a
        elif o in ("-h", "--help"):
            usage()
            sys.exit(0)
        elif o in ("-s", "--shade-mapping-adjust"):
            SHADE_MAPPING_ADJUST = float(a)

    try:
        dist_vars, cond_vars = common.parse_dist_cond_vars_spec(dist_cond_vars_spec)
    except ValueError as e:
        print(f"error parsing --by specification {dist_cond_vars_spec!r}: {e}")
        sys.exit(1)

    try:
        work_identifier, tei_filename, expectancy_filename = args
    except ValueError:
        print("error: usage error", file=sys.stderr)
        print(file=sys.stderr)
        usage(sys.stderr)
        sys.exit(1)

    with open(expectancy_filename) as expectancy_file:
        expectancy = parse_expectancy(expectancy_file, dist_vars, cond_vars)

    with open(tei_filename) as tei_file:
        process(tei_file, work_identifier, expectancy, dist_vars, cond_vars)

if __name__ == "__main__":
    main()
